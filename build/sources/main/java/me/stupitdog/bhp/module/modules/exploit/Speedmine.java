package me.stupitdog.bhp.module.modules.exploit;

import me.stupitdog.bhp.event.events.DamageBlockEvent;
import me.stupitdog.bhp.event.events.PacketEvent;
import me.stupitdog.bhp.module.Category;
import me.stupitdog.bhp.module.Module;
import me.stupitdog.bhp.setting.Setting;
import me.stupitdog.bhp.util.Timer;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Items;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class Speedmine extends Module {

	private BlockPos renderBlock;
	private BlockPos lastBlock;
	private boolean packetCancel = false;
	private Timer breaktimer = new Timer();
	private EnumFacing direction;
	
	private Setting<Boolean> autoBreak = this.register(new Setting<Boolean>("AutoBreak",true));
	private Setting<Boolean> picOnly = this.register(new Setting<Boolean>("PicOnly",true));
	private Setting<Integer> delay = this.register(new Setting<Integer>("Delay",20,0,500));
	
	public Speedmine() {
		super("Speedmine","",Category.EXPLOITS);
	}
	
	@Override
	public void onUpdate() {
		if(renderBlock != null) {
			if(autoBreak.getValue() && breaktimer.hasReached((long) delay.getValue())) {
				if(picOnly.getValue()&&!(mc.player.getHeldItem(EnumHand.MAIN_HAND).getItem() == Items.DIAMOND_PICKAXE)) return;
				mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
						renderBlock, direction));
				breaktimer.reset();
			}

		}
		
		try {
			mc.playerController.blockHitDelay = 0;

		} catch (Exception e) {
		}
	}

	@SuppressWarnings("rawtypes")
	@SubscribeEvent
	public void packetListener(PacketEvent.Send event) {
		Packet packet = event.getPacket();
		if (packet instanceof CPacketPlayerDigging) {
			CPacketPlayerDigging digPacket = (CPacketPlayerDigging) packet;
			if(((CPacketPlayerDigging) packet).getAction()== CPacketPlayerDigging.Action.START_DESTROY_BLOCK && packetCancel) event.cancel();
		}
	}

	@SubscribeEvent
	public void damageListener(DamageBlockEvent event) {
		if (canBreak(event.getBlockPos())) {

			if(lastBlock==null||event.getBlockPos().x!=lastBlock.x || event.getBlockPos().y!=lastBlock.y || event.getBlockPos().z!=lastBlock.z) {
				//Command.sendChatMessage("New Block");
				packetCancel = false;
				//Command.sendChatMessage(p_Event.getPos()+" : "+lastBlock);
				mc.player.swingArm(EnumHand.MAIN_HAND);
				mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK,
						event.getBlockPos(), event.getEnumFacing()));
				packetCancel = true;
			}else{
				packetCancel = true;
			}
			//Command.sendChatMessage("Breaking");
			mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
					event.getBlockPos(), event.getEnumFacing()));

			renderBlock = event.getBlockPos();
			lastBlock = event.getBlockPos();
			direction = event.getEnumFacing();

			event.cancel();

		}
	}

	@SuppressWarnings("deprecation")
	private boolean canBreak(BlockPos pos) {
		final IBlockState blockState = mc.world.getBlockState(pos);
		final Block block = blockState.getBlock();

		return block.getBlockHardness(blockState, mc.world, pos) != -1;
	}

	public BlockPos getTarget(){
		return renderBlock;
	}

	public void setTarget(BlockPos pos){
		renderBlock = pos;
		packetCancel = false;
		mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK,
				pos, EnumFacing.DOWN));
		packetCancel = true;
		mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
				pos, EnumFacing.DOWN));
		direction = EnumFacing.DOWN;
		lastBlock = pos;
	}
}
